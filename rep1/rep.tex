\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{listings}

\title{Ввод--вывод языка Си}

\begin{document}
\maketitle
\lstset{language=C}

\section{История}
\subsection{Си}
Язык Си появился в 70-ых годах, чтобы переписать первую версию системы
Unix на PDP--11/7, который поддерживал байтовую адресацию и разные
скалярные типы.  То, как устроен ввод--вывод в Си, во многом
определилось этими условиями.  Тогда была эра Алгол-подобных языков,
поэтому Си является примером императивного вон-неймановского языка,
поддерживающего методологию структурного программирования.

Что следует из этой общей характеристики? Во-первых, будучи языком
написания операционной системы, первые компиляторы Си не имели никакой
необходимости иметь операторы ввода--вывода.  Системные вызовы,
которые обеспечивали ввод--вывод, были почти автоматически доступны
(сейчас на amd64 нужно лишь написать ассемблерную обертку для
syscall'а).  Библиотека полезных функций росла вместе с языком.
Также стандартная библиотека ввода--вывода во многом основана на модели
ввода--вывода Unix.


Во-вторых, основным механизмом абстракции Си является абстракция
управления, предоставляемая подпрограммами, называемыми в терминах Си,
функциями. Эти функции являются параметризованными алгоритмами,
которые могут вызываться повторно использоваться. Хорошо написанная
функция характеризуется тем, что при выполнении ряда утверждений,
называемых пред-условиями, вызов функции переводит состояние
вычислительного процесса, при котором выполняется набор пост-условий.


Во-третьих, абстракция данных Си представлена иерархией типов
основанных на простых скалярных типах и пустом типе и конструкторах
новых типов: массивов, функций, структур, объединений, указателей и
перечислений. Чтобы не писать длинные названия типов и обеспечить
некоторое сокрытие (инкапсуляцию) есть механизм именования типов. Еще
важным механизмом сокрытия является наличие неполных типов и
возможность файловой области видимости.

\subsection{Стандартной библиотеки}
В тех же 70-ых стало понятно, что Си распространится за пределы мира
Unix и М. Леск разработал в 72--73 годах переносимую библиотеку,
описание которой опубликовал под называние ``A Portable I/O Package''
внутри Bell Labs. Следующим годом Деннис Ритчи переписал ее и в более
менее оформленном виде она предстала во втором издании K\&R.

Отсюда замечается интересная особенность. Всё это происходило до
появления макропроцессора у Си. На Unix системный вызов
\lstinline{open()} в качестве резжима принимал магические константы,
поэтому \lstinline{fopen()} использует более читаемые
строки.

Не все операционные системы оформляют доступ к вводу--вывода в виде
таблицы/массива, в которой можно было бы выбрать позицию целым числом
--- файловым дескриптором. Указатель на какой-то тип позволил бы Си
использоваться на системах, где для этих целей используются другие
структуры данных (отсюда и запрет копирования \lstinline{FILE}). В
будущем с усиление строгости типизации \lstinline{FILE *} сделал
программирование более безопасным, хотя такая цель не могла
преследоваться на старом Си.

\section{Модель ввода--вывода Си}
В центре ввода--вывода Си стоит понятие потока --- некоторого способа
получать последовательности байт, который позволяет отвлечься от
отдельного источника/приёмника данных. Состояние потока описывается
абстрактным типом \lstinline{FILE}. Неизвестно полный ли этот тип или
нет. Прикладной программист имеет дело лишь с указателем на объект
типа \lstinline{FILE}. В этом есть явные преимущества: указатели ---
небольшие скалярные типы, поэтому стоимость вызова функций с
аргументом или результатом этого типа мала, также указатели имеют
выделенное нессылающее значение \lstinline{NULL}, что позволяет
проверять успех операций.

Потоки могут иметь разное направление и подразделяются в Си на
текстовые и двоичные, байтовые и широкие, с позиционированием и
без. Текстовые потоки разбиты на строки символами конца
строки. Двоичные позволяют записывать объекты из памяти, не изменяя их
представления при чтении.

В связи с интернационализацией в Си-90 была включена возможность
поддержки символов текста, имеющих коды, большие, чем позволял тип
\lstinline{char}. Кодировки с переменным количеством байт бы осложняли
позиционирование в строках, поэтому ввод--вывод продублирован на базе
\lstinline{wchar_t}. Тип первой функции ввода--вывода определяет
ориентацию на широкие и байтовые у потока.

Некоторые устройства имеют возможность позиционирования: можно перейти
в определенное место файла на диске или магнитной ленте, а на других нет
--- это терминалы, порты. С Unix сразу соотносятся \lstinline{fseek()}
и \lstinline{ftell()}.

В связи со свойствами иерархии запоминающих устройств, стандартная
библиотека поддерживает буферизацию: ее может не быть, она может быть
построчная или полная. При буферизации значение переносится в массив,
ожидая момента, когда значительный кусок может быть передан разом.

Из-за буферизации потоки, имеющие направление ввода и вывода, требуют
сброса буфера \lstinline{fflush()} между операциями разных
направлений. 

Формально тип характеризуется множеством значений и операций. Из
потоков даны указатели на \lstinline{stdin} (стандартный ввод),
\lstinline{stdout} (стандартный вывод) и \lstinline{stderr}
(диагностический вывод). Стандартный вывод на интерактивное устройство
обычно построчно буферизован, а диагностический вывод небуферизован.

Среди операций есть создающая \lstinline{fopen()} (открыть по имени и
режиму), уничтожающая \lstinline{fclose()} и делающая и то и другое
\lstinline{freopen()}. Важно отметить, что во-первых потоки являются
ограниченным ресурсом (гарантировано \lstinline{_FOPEN_MAX}), и
во-вторых, операции с ними вовлекают системные вызовы, и поэтому
\emph{возвращаемые значения функций должны проверяться}.

Режимы указывают направления ``w'' обозначает
запись/создание/обрезку, ``r'' --- чтение, ``a'' --- добавление, ``+''
--- на возможность другого направления.

\section{Некоторые функции ввода--вывода}
\subsection{fgetc}
\begin{lstlisting}
  int fgetc(FILE *stream);
  int ungetc(int c, FILE *stream);
\end{lstlisting}

Первая осуществляет побайтовое чтение потока. В случае конца
возвращает отрицательное \lstinline{EOF} вне типа
\lstinline{char}. Самая базовая текстовая функция, с помощью которой
можно осуществлять все, что угодно, если писать подобие автоматов с
конечным числом состояний.

Функция \lstinline{ungetc()} позволяет положить прочитанный символ
назад (можно рассчитывать на один). Хорошо, когда одна программа
забрала не больше ввода, чем нужно. Также $LR(1)$ класс сильнее
$LR(0)$.
\subsection{fgets}
\begin{lstlisting}
  char *fgets(char *s, int size, FILE *stream);
\end{lstlisting}

Читает строку в первый аргумент, размер с учетом завершающего
нуля. Неудобна из-за конца символа строки. И возвращает
\lstinline{NULL}, как гадкий утёнок.

\subsection{fputc, fputs}
Универсальные и простые функции вывода.
\subsection{fread, fwrite}
\begin{lstlisting}
  size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
  size_t fwrite(const void *ptr, size_t size, size_t nmemb,
                FILE *stream);
\end{lstlisting}
Умеют записывать любые массивы в двоичные потоки. Например, программа
наработала много данных. Можно временно выбросить на диск. Они ближе
всего к базовым системным вызовам.

\subsection{Форматированный ввод--вывод}
Позволяют пользоваться целым под-языком спецификаций, но функции ввода
хрупки при пользовательском вводе, хотя возвращаемое значение (число
удачных присваиваний) удобно. Принимают указатель на поток первым
аргументом.
\end{document}